/**
 * üéØ EXEMPLO PR√ÅTICO: Grafos B√°sicos
 * 
 * Este programa demonstra as duas principais formas de representar grafos:
 * - Matriz de Adjac√™ncia
 * - Lista de Adjac√™ncia
 * 
 * Inclui exemplos pr√°ticos baseados nas 7 Pontes de K√∂nigsberg
 * e aplica√ß√µes em redes sociais e mapas.
 * 
 * Compile: gcc grafos_basico.c -o grafos_basico
 * Execute: ./grafos_basico
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

// Defini√ß√µes para o tamanho m√°ximo do grafo
#define MAX_VERTICES 10

// ===== ESTRUTURAS PARA LISTA DE ADJAC√äNCIA =====
typedef struct No {
    int vertice;
    int peso;           // Para grafos ponderados
    struct No* proximo;
} No;

typedef struct {
    No* cabeca;
    char nome[20];      // Nome do v√©rtice (ex: "Jo√£o", "Cidade A")
} ListaAdjacencia;

// ===== ESTRUTURA PARA GRAFO =====
typedef struct {
    int matriz[MAX_VERTICES][MAX_VERTICES];  // Matriz de adjac√™ncia
    ListaAdjacencia lista[MAX_VERTICES];     // Lista de adjac√™ncia
    int num_vertices;
    bool eh_direcionado;
    bool eh_ponderado;
} Grafo;

// ===== FUN√á√ïES AUXILIARES =====

void limpar_tela() {
    #ifdef _WIN32
        system("cls");
    #else
        system("clear");
    #endif
}

void pausar() {
    printf("\nPressione Enter para continuar...");
    getchar();
    getchar();
}

// ===== FUN√á√ïES DE INICIALIZA√á√ÉO =====

Grafo* criar_grafo(int num_vertices, bool direcionado, bool ponderado) {
    Grafo* grafo = (Grafo*)malloc(sizeof(Grafo));
    
    grafo->num_vertices = num_vertices;
    grafo->eh_direcionado = direcionado;
    grafo->eh_ponderado = ponderado;
    
    // Inicializar matriz de adjac√™ncia
    for (int i = 0; i < MAX_VERTICES; i++) {
        for (int j = 0; j < MAX_VERTICES; j++) {
            grafo->matriz[i][j] = 0;
        }
    }
    
    // Inicializar lista de adjac√™ncia
    for (int i = 0; i < MAX_VERTICES; i++) {
        grafo->lista[i].cabeca = NULL;
        sprintf(grafo->lista[i].nome, "V%d", i);
    }
    
    return grafo;
}

void definir_nome_vertice(Grafo* grafo, int vertice, const char* nome) {
    if (vertice >= 0 && vertice < grafo->num_vertices) {
        strcpy(grafo->lista[vertice].nome, nome);
    }
}

// ===== FUN√á√ïES PARA MATRIZ DE ADJAC√äNCIA =====

void adicionar_aresta_matriz(Grafo* grafo, int origem, int destino, int peso) {
    if (origem >= 0 && origem < grafo->num_vertices && 
        destino >= 0 && destino < grafo->num_vertices) {
        
        if (grafo->eh_ponderado) {
            grafo->matriz[origem][destino] = peso;
        } else {
            grafo->matriz[origem][destino] = 1;
        }
        
        // Se n√£o √© direcionado, adiciona a aresta inversa
        if (!grafo->eh_direcionado) {
            grafo->matriz[destino][origem] = grafo->matriz[origem][destino];
        }
    }
}

void imprimir_matriz_adjacencia(Grafo* grafo) {
    printf("\nüî¢ MATRIZ DE ADJAC√äNCIA\n");
    printf("=" * 40);
    printf("\n\n    ");
    
    // Cabe√ßalho das colunas
    for (int i = 0; i < grafo->num_vertices; i++) {
        printf("%8s", grafo->lista[i].nome);
    }
    printf("\n");
    
    // Linhas da matriz
    for (int i = 0; i < grafo->num_vertices; i++) {
        printf("%s", grafo->lista[i].nome);
        for (int j = 0; j < grafo->num_vertices; j++) {
            printf("%8d", grafo->matriz[i][j]);
        }
        printf("\n");
    }
    
    printf("\nüí° Interpreta√ß√£o:\n");
    printf("   ‚Ä¢ 0 = N√£o h√° conex√£o\n");
    if (grafo->eh_ponderado) {
        printf("   ‚Ä¢ N√∫mero > 0 = Peso da aresta\n");
    } else {
        printf("   ‚Ä¢ 1 = H√° conex√£o\n");
    }
}

// ===== FUN√á√ïES PARA LISTA DE ADJAC√äNCIA =====

void adicionar_aresta_lista(Grafo* grafo, int origem, int destino, int peso) {
    if (origem >= 0 && origem < grafo->num_vertices && 
        destino >= 0 && destino < grafo->num_vertices) {
        
        // Criar novo n√≥
        No* novo_no = (No*)malloc(sizeof(No));
        novo_no->vertice = destino;
        novo_no->peso = peso;
        novo_no->proximo = grafo->lista[origem].cabeca;
        grafo->lista[origem].cabeca = novo_no;
        
        // Se n√£o √© direcionado, adiciona a aresta inversa
        if (!grafo->eh_direcionado) {
            No* novo_no_inv = (No*)malloc(sizeof(No));
            novo_no_inv->vertice = origem;
            novo_no_inv->peso = peso;
            novo_no_inv->proximo = grafo->lista[destino].cabeca;
            grafo->lista[destino].cabeca = novo_no_inv;
        }
    }
}

void imprimir_lista_adjacencia(Grafo* grafo) {
    printf("\nüìã LISTA DE ADJAC√äNCIA\n");
    printf("=" * 40);
    printf("\n");
    
    for (int i = 0; i < grafo->num_vertices; i++) {
        printf("%s -> ", grafo->lista[i].nome);
        
        No* atual = grafo->lista[i].cabeca;
        if (atual == NULL) {
            printf("‚àÖ (nenhuma conex√£o)");
        } else {
            while (atual != NULL) {
                if (grafo->eh_ponderado) {
                    printf("%s(peso:%d)", grafo->lista[atual->vertice].nome, atual->peso);
                } else {
                    printf("%s", grafo->lista[atual->vertice].nome);
                }
                atual = atual->proximo;
                if (atual != NULL) {
                    printf(" -> ");
                }
            }
        }
        printf("\n");
    }
}

// ===== AN√ÅLISE DO GRAFO =====

int calcular_grau_vertice(Grafo* grafo, int vertice) {
    int grau = 0;
    
    if (grafo->eh_direcionado) {
        // Para grafos direcionados, calcular grau de sa√≠da
        for (int i = 0; i < grafo->num_vertices; i++) {
            if (grafo->matriz[vertice][i] > 0) {
                grau++;
            }
        }
    } else {
        // Para grafos n√£o direcionados
        for (int i = 0; i < grafo->num_vertices; i++) {
            if (grafo->matriz[vertice][i] > 0) {
                grau++;
            }
        }
    }
    
    return grau;
}

bool eh_conexo(Grafo* grafo) {
    // Verifica√ß√£o simplificada para grafos pequenos
    // Em grafos maiores, usar√≠amos DFS ou BFS
    
    for (int i = 0; i < grafo->num_vertices; i++) {
        bool tem_conexao = false;
        for (int j = 0; j < grafo->num_vertices; j++) {
            if (i != j && (grafo->matriz[i][j] > 0 || grafo->matriz[j][i] > 0)) {
                tem_conexao = true;
                break;
            }
        }
        if (!tem_conexao && grafo->num_vertices > 1) {
            return false;
        }
    }
    return true;
}

void analisar_grafo(Grafo* grafo) {
    printf("\nüìä AN√ÅLISE DO GRAFO\n");
    printf("=" * 40);
    printf("\n");
    
    printf("Tipo: %s %s\n", 
           grafo->eh_direcionado ? "Direcionado" : "N√£o-direcionado",
           grafo->eh_ponderado ? "Ponderado" : "Simples");
    
    printf("N√∫mero de v√©rtices: %d\n", grafo->num_vertices);
    
    // Calcular n√∫mero de arestas
    int num_arestas = 0;
    for (int i = 0; i < grafo->num_vertices; i++) {
        for (int j = 0; j < grafo->num_vertices; j++) {
            if (grafo->matriz[i][j] > 0) {
                num_arestas++;
            }
        }
    }
    if (!grafo->eh_direcionado) {
        num_arestas /= 2; // Cada aresta √© contada duas vezes
    }
    printf("N√∫mero de arestas: %d\n", num_arestas);
    
    // Grau dos v√©rtices
    printf("\nGrau dos v√©rtices:\n");
    for (int i = 0; i < grafo->num_vertices; i++) {
        int grau = calcular_grau_vertice(grafo, i);
        printf("  %s: grau %d", grafo->lista[i].nome, grau);
        
        if (grau == 0) printf(" (isolado)");
        else if (grau == grafo->num_vertices - 1) printf(" (conectado a todos)");
        
        printf("\n");
    }
    
    // Conectividade
    printf("\nConectividade: %s\n", eh_conexo(grafo) ? "‚úÖ Conexo" : "‚ùå Desconexo");
}

// ===== EXEMPLOS CL√ÅSSICOS =====

void exemplo_pontes_konigsberg() {
    printf("\nüåâ EXEMPLO: As 7 Pontes de K√∂nigsberg\n");
    printf("=" * 50);
    printf("\n");
    printf("Problema hist√≥rico que deu origem √† teoria dos grafos!\n");
    printf("Pergunta: √â poss√≠vel atravessar todas as 7 pontes exatamente uma vez?\n\n");
    
    // Criar grafo das pontes de K√∂nigsberg
    Grafo* konigsberg = criar_grafo(4, false, false);
    
    // Definir nomes dos v√©rtices (massas de terra)
    definir_nome_vertice(konigsberg, 0, "Norte");
    definir_nome_vertice(konigsberg, 1, "Sul");
    definir_nome_vertice(konigsberg, 2, "Leste");
    definir_nome_vertice(konigsberg, 3, "Oeste");
    
    // Adicionar as 7 pontes
    adicionar_aresta_matriz(konigsberg, 0, 1, 1); // Norte-Sul: 1 ponte
    adicionar_aresta_matriz(konigsberg, 0, 2, 2); // Norte-Leste: 2 pontes
    adicionar_aresta_matriz(konigsberg, 0, 3, 2); // Norte-Oeste: 2 pontes
    adicionar_aresta_matriz(konigsberg, 1, 2, 1); // Sul-Leste: 1 ponte
    adicionar_aresta_matriz(konigsberg, 1, 3, 1); // Sul-Oeste: 1 ponte
    
    // Reconstruir para lista de adjac√™ncia
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (konigsberg->matriz[i][j] > 0) {
                // Adicionar m√∫ltiplas arestas se necess√°rio
                for (int k = 0; k < konigsberg->matriz[i][j]; k++) {
                    adicionar_aresta_lista(konigsberg, i, j, 1);
                }
            }
        }
    }
    
    imprimir_matriz_adjacencia(konigsberg);
    analisar_grafo(konigsberg);
    
    printf("\nüéØ Solu√ß√£o de Euler (1736):\n");
    printf("Para existir um caminho que passe por todas as arestas exatamente\n");
    printf("uma vez, o grafo deve ter no m√°ximo 2 v√©rtices de grau √≠mpar.\n");
    printf("Neste caso, todos os 4 v√©rtices t√™m grau √≠mpar!\n");
    printf("Conclus√£o: ‚ùå IMPOSS√çVEL atravessar todas as pontes uma s√≥ vez.\n");
    
    free(konigsberg);
    pausar();
}

void exemplo_rede_social() {
    limpar_tela();
    printf("\nüë• EXEMPLO: Rede Social (Instagram/Facebook)\n");
    printf("=" * 50);
    printf("\n");
    printf("Modelando rela√ß√µes de 'seguir' em uma rede social.\n");
    printf("Grafo DIRECIONADO: A seguir B n√£o implica B seguir A.\n\n");
    
    Grafo* rede = criar_grafo(5, true, false); // Direcionado, n√£o ponderado
    
    // Definir usu√°rios
    definir_nome_vertice(rede, 0, "Alice");
    definir_nome_vertice(rede, 1, "Bob");
    definir_nome_vertice(rede, 2, "Carol");
    definir_nome_vertice(rede, 3, "Dave");
    definir_nome_vertice(rede, 4, "Eva");
    
    // Rela√ß√µes de "seguir"
    adicionar_aresta_matriz(rede, 0, 1, 1); // Alice segue Bob
    adicionar_aresta_matriz(rede, 0, 2, 1); // Alice segue Carol
    adicionar_aresta_matriz(rede, 1, 0, 1); // Bob segue Alice (rec√≠proco)
    adicionar_aresta_matriz(rede, 1, 3, 1); // Bob segue Dave
    adicionar_aresta_matriz(rede, 2, 0, 1); // Carol segue Alice
    adicionar_aresta_matriz(rede, 2, 4, 1); // Carol segue Eva
    adicionar_aresta_matriz(rede, 3, 1, 1); // Dave segue Bob
    adicionar_aresta_matriz(rede, 4, 2, 1); // Eva segue Carol
    adicionar_aresta_matriz(rede, 4, 3, 1); // Eva segue Dave
    
    // Reconstruir lista de adjac√™ncia
    for (int i = 0; i < rede->num_vertices; i++) {
        for (int j = 0; j < rede->num_vertices; j++) {
            if (rede->matriz[i][j] > 0) {
                adicionar_aresta_lista(rede, i, j, 1);
            }
        }
    }
    
    imprimir_matriz_adjacencia(rede);
    imprimir_lista_adjacencia(rede);
    analisar_grafo(rede);
    
    printf("\nüí° Aplica√ß√µes em Redes Sociais:\n");
    printf("‚Ä¢ Sugest√£o de amigos (amigos em comum)\n");
    printf("‚Ä¢ Detec√ß√£o de influenciadores (alto grau de entrada)\n");
    printf("‚Ä¢ Algoritmos de recomenda√ß√£o\n");
    printf("‚Ä¢ Detec√ß√£o de comunidades\n");
    
    free(rede);
    pausar();
}

void exemplo_mapa_cidades() {
    limpar_tela();
    printf("\nüó∫Ô∏è  EXEMPLO: Mapa de Cidades (GPS/Google Maps)\n");
    printf("=" * 50);
    printf("\n");
    printf("Modelando rotas entre cidades com dist√¢ncias.\n");
    printf("Grafo N√ÉO-DIRECIONADO PONDERADO: estradas de m√£o dupla com quilometragem.\n\n");
    
    Grafo* mapa = criar_grafo(6, false, true); // N√£o direcionado, ponderado
    
    // Definir cidades
    definir_nome_vertice(mapa, 0, "S√£o Paulo");
    definir_nome_vertice(mapa, 1, "Rio de Janeiro");
    definir_nome_vertice(mapa, 2, "Belo Horizonte");
    definir_nome_vertice(mapa, 3, "Bras√≠lia");
    definir_nome_vertice(mapa, 4, "Salvador");
    definir_nome_vertice(mapa, 5, "Curitiba");
    
    // Adicionar rotas com dist√¢ncias (km)
    adicionar_aresta_matriz(mapa, 0, 1, 430);  // SP - RJ
    adicionar_aresta_matriz(mapa, 0, 2, 580);  // SP - BH
    adicionar_aresta_matriz(mapa, 0, 3, 1150); // SP - Bras√≠lia
    adicionar_aresta_matriz(mapa, 0, 5, 410);  // SP - Curitiba
    adicionar_aresta_matriz(mapa, 1, 2, 440);  // RJ - BH
    adicionar_aresta_matriz(mapa, 2, 3, 740);  // BH - Bras√≠lia
    adicionar_aresta_matriz(mapa, 2, 4, 1200); // BH - Salvador
    adicionar_aresta_matriz(mapa, 3, 4, 1130); // Bras√≠lia - Salvador
    
    // Reconstruir lista de adjac√™ncia
    for (int i = 0; i < mapa->num_vertices; i++) {
        for (int j = 0; j < mapa->num_vertices; j++) {
            if (mapa->matriz[i][j] > 0) {
                adicionar_aresta_lista(mapa, i, j, mapa->matriz[i][j]);
            }
        }
    }
    
    imprimir_matriz_adjacencia(mapa);
    imprimir_lista_adjacencia(mapa);
    analisar_grafo(mapa);
    
    printf("\nüí° Aplica√ß√µes em Mapas:\n");
    printf("‚Ä¢ Algoritmo de Dijkstra (menor caminho)\n");
    printf("‚Ä¢ Planejamento de rotas otimizadas\n");
    printf("‚Ä¢ An√°lise de tr√°fego e congestionamentos\n");
    printf("‚Ä¢ Log√≠stica de entregas\n");
    
    free(mapa);
    pausar();
}

// ===== COMPARA√á√ÉO MATRIZ vs LISTA =====

void comparar_representacoes() {
    limpar_tela();
    printf("\n‚öñÔ∏è  COMPARA√á√ÉO: Matriz vs Lista de Adjac√™ncia\n");
    printf("=" * 55);
    printf("\n");
    
    printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ    CARACTER√çSTICA   ‚îÇ   MATRIZ ADJAC√äNCIA ‚îÇ   LISTA ADJAC√äNCIA  ‚îÇ\n");
    printf("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n");
    printf("‚îÇ Espa√ßo (Mem√≥ria)    ‚îÇ O(V¬≤) - sempre      ‚îÇ O(V + E) - eficiente‚îÇ\n");
    printf("‚îÇ Verificar Aresta    ‚îÇ O(1) - instant√¢neo  ‚îÇ O(grau) - sequencial‚îÇ\n");
    printf("‚îÇ Listar Vizinhos     ‚îÇ O(V) - percorre linha‚îÇ O(grau) - direto   ‚îÇ\n");
    printf("‚îÇ Adicionar Aresta    ‚îÇ O(1) - simples      ‚îÇ O(1) - no in√≠cio    ‚îÇ\n");
    printf("‚îÇ Grafos Esparsos     ‚îÇ ‚ùå Desperdi√ßa espa√ßo ‚îÇ ‚úÖ Muito eficiente  ‚îÇ\n");
    printf("‚îÇ Grafos Densos       ‚îÇ ‚úÖ Eficiente         ‚îÇ ‚ùå Muitos ponteiros ‚îÇ\n");
    printf("‚îÇ Implementa√ß√£o       ‚îÇ ‚úÖ Mais simples      ‚îÇ ‚ùå Mais complexa    ‚îÇ\n");
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    
    printf("\nüéØ QUANDO USAR CADA UMA:\n\n");
    
    printf("üìä MATRIZ DE ADJAC√äNCIA:\n");
    printf("  ‚úÖ Grafos densos (muitas arestas)\n");
    printf("  ‚úÖ Verifica√ß√µes frequentes de conectividade\n");
    printf("  ‚úÖ Algoritmos que precisam de acesso r√°pido\n");
    printf("  ‚úÖ Grafos pequenos a m√©dios\n");
    printf("  ‚ùå Grafos esparsos (poucas arestas)\n");
    printf("  ‚ùå Grafos muito grandes\n\n");
    
    printf("üìã LISTA DE ADJAC√äNCIA:\n");
    printf("  ‚úÖ Grafos esparsos (poucas arestas)\n");
    printf("  ‚úÖ Percorrer vizinhos √© comum\n");
    printf("  ‚úÖ Grafos que mudam frequentemente\n");
    printf("  ‚úÖ Grafos muito grandes\n");
    printf("  ‚ùå Verifica√ß√µes frequentes de arestas espec√≠ficas\n");
    printf("  ‚ùå Grafos muito densos\n\n");
    
    printf("üí° DICA PR√ÅTICA:\n");
    printf("   Em aplica√ß√µes reais, a escolha depende do padr√£o de uso:\n");
    printf("   ‚Ä¢ Redes sociais: Lista (esparsas, mudam frequentemente)\n");
    printf("   ‚Ä¢ Mapas rodovi√°rios: Lista (esparsas, geograficamente limitadas)\n");
    printf("   ‚Ä¢ Grafos completos: Matriz (todas as conex√µes existem)\n");
    
    pausar();
}

// ===== MENU PRINCIPAL =====

void mostrar_menu() {
    limpar_tela();
    printf("üéØ GRAFOS B√ÅSICOS - MENU INTERATIVO\n");
    printf("=" * 40);
    printf("\n");
    printf("Escolha uma op√ß√£o:\n\n");
    printf("1Ô∏è‚É£  üåâ As 7 Pontes de K√∂nigsberg (Problema Hist√≥rico)\n");
    printf("2Ô∏è‚É£  üë• Rede Social (Grafo Direcionado)\n");
    printf("3Ô∏è‚É£  üó∫Ô∏è  Mapa de Cidades (Grafo Ponderado)\n");
    printf("4Ô∏è‚É£  ‚öñÔ∏è  Comparar Matriz vs Lista\n");
    printf("5Ô∏è‚É£  üìö Teoria dos Grafos (Conceitos)\n");
    printf("0Ô∏è‚É£  üö™ Sair\n");
    printf("\n" + "=" * 40);
    printf("\nSua escolha: ");
}

void mostrar_teoria() {
    limpar_tela();
    printf("\nüìö TEORIA DOS GRAFOS - CONCEITOS FUNDAMENTAIS\n");
    printf("=" * 55);
    printf("\n");
    
    printf("üéØ DEFINI√á√ÉO:\n");
    printf("   Um grafo G = (V, E) onde:\n");
    printf("   ‚Ä¢ V = conjunto de v√©rtices (n√≥s)\n");
    printf("   ‚Ä¢ E = conjunto de arestas (conex√µes)\n\n");
    
    printf("üîÑ TIPOS DE GRAFOS:\n");
    printf("   ‚Ä¢ Direcionado: arestas t√™m sentido (‚Üí)\n");
    printf("   ‚Ä¢ N√£o-direcionado: arestas s√£o bidirecionais (‚Üî)\n");
    printf("   ‚Ä¢ Ponderado: arestas t√™m peso/custo\n");
    printf("   ‚Ä¢ Simples: sem la√ßos nem m√∫ltiplas arestas\n\n");
    
    printf("üìä PROPRIEDADES IMPORTANTES:\n");
    printf("   ‚Ä¢ Grau: n√∫mero de conex√µes de um v√©rtice\n");
    printf("   ‚Ä¢ Caminho: sequ√™ncia de v√©rtices conectados\n");
    printf("   ‚Ä¢ Ciclo: caminho que volta ao v√©rtice inicial\n");
    printf("   ‚Ä¢ Conectividade: possibilidade de ir de qualquer v√©rtice a outro\n\n");
    
    printf("üåç APLICA√á√ïES NO MUNDO REAL:\n");
    printf("   ‚Ä¢ üåê Internet: p√°ginas (v√©rtices) e links (arestas)\n");
    printf("   ‚Ä¢ üë• Redes sociais: pessoas e relacionamentos\n");
    printf("   ‚Ä¢ üó∫Ô∏è  GPS: cidades e estradas\n");
    printf("   ‚Ä¢ ‚ö° Redes el√©tricas: usinas e transmiss√£o\n");
    printf("   ‚Ä¢ üß¨ Biologia: prote√≠nas e intera√ß√µes\n");
    printf("   ‚Ä¢ ü§ñ IA: redes neurais e processamento\n\n");
    
    printf("üéØ ALGORITMOS CL√ÅSSICOS:\n");
    printf("   ‚Ä¢ Busca em largura (BFS)\n");
    printf("   ‚Ä¢ Busca em profundidade (DFS)\n");
    printf("   ‚Ä¢ Dijkstra (menor caminho)\n");
    printf("   ‚Ä¢ Floyd-Warshall (todos os caminhos)\n");
    printf("   ‚Ä¢ Kruskal/Prim (√°rvore geradora m√≠nima)\n");
    
    pausar();
}

// ===== FUN√á√ÉO PRINCIPAL =====

int main() {
    int opcao;
    
    do {
        mostrar_menu();
        scanf("%d", &opcao);
        
        switch (opcao) {
            case 1:
                exemplo_pontes_konigsberg();
                break;
            case 2:
                exemplo_rede_social();
                break;
            case 3:
                exemplo_mapa_cidades();
                break;
            case 4:
                comparar_representacoes();
                break;
            case 5:
                mostrar_teoria();
                break;
            case 0:
                limpar_tela();
                printf("\nüéâ Obrigado por explorar o mundo dos Grafos!\n");
                printf("üí° Continue estudando - grafos s√£o fundamentais na computa√ß√£o!\n\n");
                break;
            default:
                printf("\n‚ùå Op√ß√£o inv√°lida! Tente novamente.\n");
                pausar();
        }
    } while (opcao != 0);
    
    return 0;
}

/**
 * üéì PONTOS DE APRENDIZADO:
 * 
 * 1. REPRESENTA√á√ÉO:
 *    ‚Ä¢ Matriz: boa para grafos densos, acesso O(1)
 *    ‚Ä¢ Lista: boa para grafos esparsos, economia de mem√≥ria
 * 
 * 2. APLICA√á√ïES PR√ÅTICAS:
 *    ‚Ä¢ Problemas hist√≥ricos (Pontes de K√∂nigsberg)
 *    ‚Ä¢ Redes sociais (grafos direcionados)
 *    ‚Ä¢ Sistemas de navega√ß√£o (grafos ponderados)
 * 
 * 3. AN√ÅLISE:
 *    ‚Ä¢ Grau dos v√©rtices
 *    ‚Ä¢ Conectividade
 *    ‚Ä¢ Densidade do grafo
 * 
 * 4. ESCOLHA DA ESTRUTURA:
 *    ‚Ä¢ Considere o padr√£o de uso
 *    ‚Ä¢ Analise espa√ßo vs tempo
 *    ‚Ä¢ Pense na escalabilidade
 */